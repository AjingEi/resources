# v8工作原理

## 12 栈空间和堆空间：数据是如何存储的？
  这一讲，主要先讲JS的数据是如何存储到内存中的。  

### JS的语言类型
- JS是动态语言-运行前需要检查变量的类型：意味着可以使用同一个变量保存不同类型的数据 
- 弱语言类型-支持隐式转换：意味着你不告诉引擎变量是什么数据类型，引擎会自己计算出来。

### JS的数据类型
JS的数据类型有8种
- Boolean
- Null
- Undefined
- Number
- BigInt
- String
- Symbol
- Object

typeOf可以检测数据类型，但是检测null数据类型的时候会返回Object。

前七个是原始数据类型，最后一个是引用类型

### 内存空间
JS内存空间主要分成三种，代码空间、栈空间、堆空间
- 代码空间：主要用来存储可执行代码
- 栈空间：就是调用栈。执行上下文环境就放在调用栈中。所以基本的变量都是存储在栈空间中的执行上下文的变量环境。
- 堆空间：虽然基本变量都是存储在栈空间，但是如果是Object类型即对象类型，会把值存储在堆中，然后把堆中相应的地址复制给存储在栈中的变量。

#### 为什么不可以都存储在栈空间中？
因为栈空间管理着执行上下文，且空间较小，而引用类型又较大，存储太多会导致代码执行卡顿。

### 闭包
闭包使用外部函数的变量时，引擎会识别出是闭包，然后把相应的被闭包应用的数据存到堆中。这样就算外部函数被弹出调用栈，闭包函数还是可以到堆中找到变量。

# 13 垃圾回收：垃圾数据是如何自动回收的？
JS的垃圾回收是自动回收的。因为JS内存空间分为栈空间和堆空间。两种回收不一样：
### 栈空间的垃圾回收
 调用栈主要用来存储执行上下文，当运行到某个函数的执行上下文的时候，ESP（记录当前执行状态的指针）会指向当前函数，当当前函数执行完成，ESP会向下移动，这就是栈空间的垃圾回收，因为ESP下移之后，这会被判定为无效空间，下一次有新的执行上下文进来，就会直接覆盖这个内存。

### 堆空间的垃圾回收
执行上下文被回收之后，指向堆空间的指针也就没有了，但是堆空间的值还存在，这时候就需要JS的垃圾回收器。

首先要知道JS把堆分为新生代和老生代两个区域。新生代是内存较小且存活时间较短的对象，老生代是内存较大且存活时间较长的对象。
- 副垃圾回收器：主要负责新生代的垃圾回收。
- 主垃圾回收器：主要负责老生代的垃圾回收。

#### 副垃圾回收器
主要采用Scavenge算法来处理。就是把新生代空间分成两个部分，一半是对象区域，一半是空闲区域。  

新加入的对象都会写入到对象区域，当对象区域快满了的时候就会进行垃圾回收：首先对垃圾做标记，然后把存活的对象挨个复制到空闲区域，这样就不会有碎片空间，然后反转，把对象区域变成空闲区域，空闲区域变成对象区域。

因为要频繁的复制，所以新生代空间很小，也因为空间很小，所以当经过两次标记还存在的对象会被转移到老生代空间。

### 主垃圾回收器
主要是来自新生代转移的垃圾，或者本身就很大的垃圾。所以特点就是存活时间长且占用空间大。

主要使用的方法是标记-整理，先循环标记出垃圾数据，然后把没有被标记的全部移动到一段，避免碎片化。然后把剩下的空间清空

### 注意内存泄漏，以及学会观察内存泄漏

# 14 编译器和解释器：V8是如何执行一段JS代码的？

### 编译器和解释器
简单来说就是编译器会把代码编译成机器码。  

解释器会把代码编译成字节码，会小很多。

### V8是如何执行一段JS代码的

#### 1. 生成抽象语法书（AST）和执行上下文
编译前会把代码转化为AST，AST就相当于代码的结构化表示。编译和解释都需要AST。

AST的作用：
- Babel。例如转化ES6，先把ES6转化为AST，再将ES6语法AST转化为ES5语法的AST，最后利用ES5的AST生成JS源码。
- ESLint。也是把源码转化为AST之后判断代码的规范问题。

转化AST主要分为两个阶段：
- 分词-词法分析：把代码拆解成一个个token。
- 解析-语法分析：将token根据语法规则转化为AST。

#### 2. 生成字节码
字节码就是介于AST和机器码中间的一种代码，因为直接把AST转化为机器码会占太多内存。所以先转化为字节码。可以有效减少内存的使用

#### 3. 执行代码
如果有一段第一次执行的字节码，解释器会逐条解释执行。但是执行过程中如果发现有热点代码，即反复执行的代码，这个代码就会被编译器编译成更加高效的机器码。下一次执行的时候直接使用机器码就可以了，大大提升效率。

这种解释器加编译器就是**即使编译（JIT）**。

### JS的性能优化
1. 提升单词脚本运行速度，避免JS长任务长期霸占主线程。
2. 避免大的内联脚本。因为在解析HTML的时候，解析和编译也会占用主线程。
3. 减少JS文件容量。

