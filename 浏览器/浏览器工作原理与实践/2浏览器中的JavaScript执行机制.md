# 浏览器中的JS执行机制
这一章节主要对JavaScript执行原理做深入的介绍
## 07 变量提升：JavaScript是按顺序执行的吗？
### 变量提升
变量提升就是在JS代码执行过程中，JS会把变量的声明部分提升到代码开头的行为。变量提升之后，会给他赋值为undefined
### JS代码的执行流程
JS代码首先会进行**编译**，然后进入**执行阶段**。
#### 1. 编译阶段。
   - JS代码经过编译之后会被分成两部分： 执行上下文和可执行代码
        - 执行上下文是JS执行一段代码时的运行环境。它包括两个部分：**变量环境**和词法环境。变量环境对象包含了变量提升的内容。
#### 2. 执行阶段
   - 执行阶段会按照可执行代码部分，一行一行的执行，涉及到的变量部分就会到执行上下文中的变量环境查找使用。

### 变量覆盖
   - 如果声明了名字一样的变量函数，后面变量函数会覆盖前面的变量的值函数

## 08 调用栈：为什么JavaScript代码会出现栈溢出？
调用栈是用来管理函数调用关系的一种数据结构。

### 函数调用
- 从全局上下文中的变量环境取出函数的代码
- 对函数的代码进行编译，创建函数的执行上下文和可执行代码
- 执行代码

### 调用栈
- JS引擎追踪函数执行的一个机制。
- 栈底是全局上下文，函数内部再运行函数，就会再调用栈上累计。超过一定的大小就会出现栈溢出。

### 如何更好的利用调用栈
- 使用浏览器查看调用栈的信息
    - 打断点，在开发者工具的位置查看call stack
    - 在函数内部输出console.trace()
- 栈溢出  
调用栈有大小

## 09 块级作用域：var缺陷以及为什么要引入let和const？
- 病因：变量提升带来了问题
- 解决：块级作用域配合let和const

### 变量提升带来的问题
- 变量容易在不被察觉的情况下被覆盖
  - 比如在函数中的if语句中声明，虽然没有运行，但是变量会存在。
- 本应销毁的变量没有被销毁
  - 循环结束后，循环中的变量没有消失。

### ES6是如何解决变量提升带来的缺陷的
引入了let和const和块级作用域。且保留了变量提升。   
主要实现机制是：
- var声明的变量不管在全局作用域还是块级作用域还是会**被提升**且被赋值为undefined，且是保存在执行上下文中的**变量环境**。
- let声明的变量都会被加到执行上下文的**词法环境**
  - 如果是在全局作用域声明的，在最开始声明就会被加到词法环境，但是在真正运行到声明执行的位置之前，使用变量会报错。
  - 如果是在块级作用域声明的，在运行到块级作用域到时候才会被加入词法环境。且和全局作用域加入到不是同一块，相当于压栈进去，块作用域运行结束之后，这一块变量就会被弹出。
  - 在块级作用域中使用变量，首先是在词法环境查找，然后是变量环境

## 10 作用域链和闭包：代码中出现相同到变量，JS引擎是如何人选择的？
函数执行有一个执行上下文的栈，但是这个栈和作用域链没有直接关系  
### 作用域链
在每个执行上下文的变量中，都包含了一个外部引用，用来指向外部的执行上下文，这个外部引用就是outer。

### 词法作用域
outer的指向是由词法作用域决定的。词法作用域是静态的作用域，是根据代码位置决定的。和函数调用没有关系

### 块级作用域的变量查找
有块级作用域的话，先找执行上下文的词法环境，再找变量环境。

### 闭包
- 闭包就是访问了外部函数变量的函数。  
- 外部函数运行结束了之后，被引用的变量依然保持在内存中。
- 可以在开发者工具中查看scope看到闭包的情况

### 闭包是怎么回收的
- 如果外部函数是一个全局变量，那闭包就不会销毁。
- 如果外部函数是一个局部变量，那局部变量失效的时候，闭包就会被销毁。

## 11 this: 从JS执行上下文的视角讲清楚this
注： 作用域链和this没有什么关系
this是和执行上下文绑定的。

### 全局执行上下文的this
是window

### 函数执行上下文的this
- 在全局环境中调用一个函数，函数的内部指向window。
- 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的this指向对象本身。

### 通过构造函数中设置
构造函数中的this指向新的创造的对象  

new 构造函数()，做了如下的事情：
- 创建一个空对象
- 调用函数.call，参数是新对象
- 执行函数
- 返回新对象

### this的缺陷
1. **this不会继承**  
   - 嵌套的函数的this指向widnow？
   - 箭头函数的this会继承父函数的   
   - 或者外部函数使用变量保存this
1. **普通函数的this默认指向widnow**