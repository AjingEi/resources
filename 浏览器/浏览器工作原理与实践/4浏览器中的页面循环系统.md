# 浏览器中的页面循环系统

## 15 消息队列和事件循环：页面是怎么活起来的？

#### 使用单线程处理安排好单任务
对事先排好对任务按顺序执行，执行完就结束。  

#### 在线程运行过程中处理新任务
但是页面运行过程中会有插入进来的新任务。所以采用**事件循环机制**。一直循环等待，有新的任务进来就执行。

#### 处理其他线程发送过来的任务
会有其他线程需要主线程执行一些任务的情况。所以出现了**消息队列**，不管是本线程的事件还是其他线程的事件，发送过来就排进消息队列队尾。事件执行完一个就从队首取出事件继续执行。

#### 处理其他进程发过来的任务
其他进程发过来的任务首先进入I/O线程，然后I/O线程把它处理后发到主线程的消息队列。

#### 消息队列中的任务类型
有各种各样的任务，在消息队列中排下来之后就会按顺序执行，有些任务占用很长的时间，应该尽量避免这些事件。

#### 如何安全退出
主线程有一个标志是否要退出的变量，每次执行完之后，主线程都会检测一下这个变量。

#### 页面使用单线程的缺陷
1. 如何处理优先级高的任务
   - 宏任务和微任务来解决。
   - 当前执行的任务是宏任务，此时加进来优先级更高的任务会把加入当前宏任务的微任务列表。微任务只有在宏任务执行的时候会创建。
   - 当前宏任务执行完成后，线程会去检查当前宏任务的微任务列表，然后挨个执行完成后，再去消息队列取任务执行。
2. 如何解决单个任务时间过长的任务  
通过回调来解决

## 16 webAPI：setTimeOut是怎么实现的？
#### 浏览器是怎么实现setTimeOut的
setTimeout时间不会加入到正常的消息队列中，而是加入到浏览器维护的另一个需要延迟执行的任务队列中。主要用来放一些延迟任务。  

触发执行方式是，每一次执行完一个消息队列中的任务后，就会去检查延迟执行的任务列表中是否有已经时间到的任务，就执行这个任务。检查执行完成后又回到消息队列中执行。

### 使用setTimeOut的注意事项
#### 1. 当前任务执行过久，会影响定时器任务的执行
因为定时器任务是需要等待当前任务执行完成之后，才可以执行，如果当前任务执行很久，即便定时器设置的时间是0，也有可能等很久才执行。

#### 2. 如果setTimeOut存在嵌套调用，系统会设置最短时间间隔4ms

#### 3. 嵌套在setTimeOut中的代码，函数的this指向会指向window。

## 17 webAPI：XMLHttpRequest是怎么实现的？

### 回调函数
将一个函数作为参数传给另一个函数，这个作为参数的函数就是回调函数

#### 同步回调和异步回调
可以直接在当前函数执行完成的回调函数，就是同步回调。需要在代码外执行的回调函数，就是异步回调。  

同步回调：
```
let callback = function (){
    console.log('回调')
}
function xx(cb){
    cb()
}
xx()
```
异步回调：
```
let callback = function (){
    console.log('回调')
}
function xx(cb){
    setTimeOut(cb(), 0) 
}
xx()
```

每个任务执行的时候会有自己的调用栈。同步回调函数就在当前函数的上下文执行。异步回调函数是在当前函数结束后执行的。

### XMLHTTPRequest执行机制
```
function getWebData(){
    let xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
            case 0: 
               console.log('请求未初始化')
               break;
            case 1: 
               console.log('OPENED')
               break;
            case 2: 
               console.log('HEADERS_RECEIVED')
               break;
            case 3: 
               console.log('LOADING')
               break;
            case 4: 
               if(this.status == 200||this.status == 304){ console.log(this.responseText); } console.log("DONE")
               break;
        }
    }
    xhr.ontimeout = function(e) { console.log('ontimeout') } 
    xhr.onerror = function(e) { console.log('onerror') } 

    /** 
     * 3:打开请求 
     */ 
    xhr.open('Get', URL, true);//创建一个Get请求,采用异步 

    /** 
     * 4:配置参数 
     */ 
    xhr.timeout = 3000 //设置xhr请求的超时时间 
    xhr.responseType = "text" //设置响应返回的数据格式 
    xhr.setRequestHeader("X_TEST","time.geekbang") 
    
    /** 
     * 5:发送请求 
     */ 
    xhr.send();
}
```

#### 具体执行步骤
 **1. 创建XMLHttpRequest对象**  
 **2. 对象设置回调函数**   
 **3. 配置基础的请求信息**  
 **4. 发起请求**  
 - 渲染进程会把请求发送到网络进程，网络进程负责资源的下载
 - 等网络进程接收到数据之后会利用IPC来通知渲染进程。
 - 渲染进程接收到之后，会把xhr的回调函数加入到消息队列中。
 - 执行回调函数的时候，判断相应的状态，执行相应的操作。

# 18 宏任务和微任务：不是所有的任务都是一个待遇
### 宏任务
加入消息队列，按顺序执行的任务。  

宏任务有一个致命的缺点，对于任务的执行不能保持失效。因为任务的执行顺序不能控制的很精准。加入消息队列的时间并不是完全按顺序的。

### 微任务
引入微任务，可以较好的保持失效。

异步回调有两种执行方式，一种是把回调函数加入消息队列尾巴。一种是把回调函数加入微任务队列。

要保证时效的话就采用第二种方式。具体机制是在将要退出宏任务的时候，检查微任务队列。然后挨个执行，这个时候有新加进来的微任务继续加入微任务队列。

# 19 promise：使用promise，告别回调函数

promise解决的是异步编码问题。

### 异步编程的问题：代码逻辑不连续。
异步回调函数穿插在正常执行的代码中，不易读。

### 封装异步代码
封装代码之后，把回调函数作为参数传入，回调函数返回成功后有可能会有新的回调函数。就会变成横向扩张。造成回调地狱。嵌套多层。

且每一层都有两个处理结果。多了之后也显得混乱。

### promise：消灭回调地狱和多次错误调用

#### 使用then
then函数参数传入回调函数。且返回值会穿透。延迟关联回调函数，就不用在创建的时候一层一层写回调函数。因为promise创建时内部函数执行的时候如果直接调用回调函数，会报错，因为还没有关联上回调函数。所以需要使用定时器。而v8内部把这个调用设置成了微任务，更加的具有时效性。

# 20 async/await：使用同步的方式去写异步的代码
